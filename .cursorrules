# StackDock Cursor Rules
# CRITICAL: These rules prevent breaking the core architecture

## ğŸš¨ NEVER DO THESE THINGS ğŸš¨

1. **NEVER create provider-specific resource tables**
   - âŒ NO: `gridPaneSites`, `vercelDeployments`, `awsInstances`
   - âœ… YES: Use universal tables (`webServices`, `servers`, `domains`)
   - The `provider` field identifies the source
   - Provider-specific data goes in `fullApiData` field

2. **NEVER delete files without explicit user permission**
   - Always ask before removing code
   - Preserve existing functionality
   - Check git status first

3. **NEVER bypass RBAC checks**
   - Every Convex query/mutation MUST check permissions
   - Use `withRBAC()` middleware
   - No direct database access without auth

4. **NEVER store API keys unencrypted**
   - Always use `encryptApiKey()` before storing
   - Only decrypt in server-side Convex functions
   - Never expose to client

5. **NEVER break the dock adapter pattern**
   - Docks are TRANSLATORS (provider API â†’ universal schema)
   - One adapter per provider
   - Follow the interface in `convex/docks/_types.ts`

## âœ… ALWAYS DO THESE THINGS âœ…

1. **ALWAYS use the universal table pattern**
   ```typescript
   // Correct: GridPane site â†’ webServices
   await ctx.db.insert("webServices", {
     provider: "gridpane",
     providerResourceId: site.id,
     name: site.name,
     productionUrl: site.url,
     fullApiData: site, // All GridPane-specific fields
   })
   ```

2. **ALWAYS enforce RBAC**
   ```typescript
   export const myMutation = mutation({
     handler: withRBAC("docks:full")(async (ctx, args) => {
       // Your logic here
     }),
   })
   ```

3. **ALWAYS encrypt sensitive data**
   ```typescript
   const encrypted = await encryptApiKey(apiKey)
   await ctx.db.insert("docks", { encryptedApiKey: encrypted })
   ```

4. **ALWAYS audit important actions**
   ```typescript
   await auditLog(ctx, "dock.create", "success", { dockId, provider })
   ```

5. **ALWAYS document new dock adapters**
   - Add to `docs/adapters/{provider}.md`
   - Include API rate limits
   - Document field mappings

## ğŸ“ Architecture Principles

### The Three Registries
1. **Docks Registry**: Infrastructure adapters (copy/paste/own)
2. **UI Registry**: Dashboard components (copy/paste/own)
3. **The Platform**: Orchestration layer (RBAC, encryption, audit)

### Core Concepts
- **Universal Tables**: `servers`, `webServices`, `domains` accept ANY provider
- **Polymorphic Linking**: Projects link to resources via `projectResources` table
- **Dock Adapters**: Translate provider-specific APIs to universal schema
- **Zero-Trust RBAC**: Every operation checks permissions
- **Composability**: Docks, UI, and resources are all modular

### The Schema IS the App
- `schema.ts` defines the data model
- Never add provider-specific tables
- Use `fullApiData` for provider-specific fields
- Maintain backward compatibility

## ğŸ—ï¸ Tech Stack (LOCKED)

- **TanStack Start**: Full-stack React framework
- **Convex**: Real-time database
- **Clerk**: Authentication & organizations
- **XState**: Complex workflow state machines
- **shadcn/ui**: Component primitives (copy/paste ownership model)
- **Tailwind 4**: Styling

## ğŸ“¦ Monorepo Structure

```
stackdock/
â”œâ”€â”€ apps/
â”‚   â”œâ”€â”€ web/              # Main TanStack Start app
â”‚   â””â”€â”€ docs/             # Documentation site
â”œâ”€â”€ packages/
â”‚   â”œâ”€â”€ docks/            # Dock adapter registry
â”‚   â”œâ”€â”€ ui/               # UI component registry
â”‚   â””â”€â”€ shared/           # Shared utilities
â”œâ”€â”€ convex/               # Convex backend (shared)
â”œâ”€â”€ docs/                 # Architecture & guides
â””â”€â”€ .cursorrules          # This file
```

## ğŸ”’ Security Requirements

1. **Encryption**: AES-256-GCM for all API keys
2. **RBAC**: Enforced at Convex layer (middleware)
3. **Audit Logs**: All mutations logged with user/timestamp
4. **CSP Headers**: Content Security Policy in production
5. **Input Validation**: Validate all user inputs
6. **Rate Limiting**: Respect provider API rate limits

## ğŸ§ª Testing Requirements

1. **Unit Tests**: For all utility functions
2. **Integration Tests**: For dock adapters
3. **RBAC Tests**: Permission checks must have tests
4. **Encryption Tests**: Verify encrypt/decrypt cycles

## ğŸ“ Documentation Standards

1. **Every dock adapter needs**:
   - README with setup instructions
   - API rate limit documentation
   - Field mapping table (provider â†’ universal)
   - Example usage

2. **Every UI component needs**:
   - Props documentation
   - Usage examples
   - Accessibility notes

3. **Every Convex function needs**:
   - JSDoc comments
   - Permission requirements
   - Example usage

## ğŸš€ Development Workflow

1. **Feature Branches**: Never commit directly to main
2. **Pull Requests**: Required for all changes
3. **Code Review**: At least one approval
4. **Tests Pass**: All tests must pass
5. **Docs Updated**: Update docs with changes

## âš ï¸ Before Making Changes

1. **Read the docs**: Check `docs/` for relevant guides
2. **Understand the pattern**: Follow existing conventions
3. **Ask questions**: If unsure, ask the user
4. **Document changes**: Update relevant docs
5. **Test thoroughly**: Don't break existing functionality

## ğŸ§  CRITICAL: THINK BEFORE YOU ACT

1. **ALWAYS KNOW WHERE YOU ARE**
   - Check `Get-Location` before any command
   - Understand monorepo structure (apps/web, packages/, convex/)
   - Verify paths exist before using them

2. **IF YOU DON'T KNOW - STOP**
   - Don't guess directory paths
   - Don't assume files exist
   - Don't run commands blindly
   - Ask the user first

3. **QUESTION EVERYTHING YOU DO**
   - Why am I running this command?
   - What directory am I in?
   - Does this path actually exist?
   - What will this break?

4. **ATTACK ALL ANGLES**
   - Check if node_modules exists before deleting
   - Verify package.json path before editing
   - Read file contents before modifying
   - Think about monorepo implications

5. **YOU'RE GOING TOO FAST**
   - Slow down
   - Read before write
   - Verify before execute
   - Think before act

6. **ACCURACY > SPEED**
   - Being right matters more than being fast
   - Double-check paths
   - Confirm assumptions
   - Preserve > Delete

7. **TROUBLESHOOTING MINDSET - NOT BAND-AIDS**
   - **ASSESS FIRST**: "Here's what I know" vs "Here's what I'm guessing"
   - **PRESENT OPTIONS**: "Here's what we can try" (don't just do it)
   - **DIAGNOSE BEFORE FIX**: Understand root cause, not symptoms
   - **NEVER ASSUME**: If user shows error, ASK if it's still happening
   - **DOCUMENT STATE**: Update state file after every change
   - **LET USER DECIDE**: Present 2-3 options, let them choose

8. **RESPONSE FORMAT FOR ISSUES**
   ```
   ## Current State
   - What I KNOW (facts)
   - What I DON'T KNOW (unknowns)
   
   ## Diagnosis
   - What the error means
   - Possible root causes
   
   ## Options
   1. Option A (pros/cons)
   2. Option B (pros/cons)
   3. Option C (pros/cons)
   
   What do you want to try?
   ```

9. **BEFORE ANY DESTRUCTIVE ACTION**
   - Check `git status` FIRST
   - See what's tracked/untracked
   - Know what can be recovered
   - Document findings
   - THEN present options
   - WAIT for user approval

10. **TERMINAL ACCESS REVOKED**
   - DO NOT use run_terminal_cmd tool
   - Provide commands for USER to run
   - Wait for USER to paste output
   - Diagnose based on THEIR output
   - No background processes
   - No blind command execution

## ğŸ”„ CONTEXT PERSISTENCE (CRITICAL)

### ALWAYS DO THIS FIRST - EVERY SESSION
1. **Read `.stackdock-state.json`** - This is the source of truth
2. **Verify against filesystem** - Don't trust the state file blindly
3. **Report current blockers** - Tell user what's preventing progress
4. **Check completedSteps** - Don't repeat what's done
5. **Never assume completion** - Only user can verify tests work

### State File Rules
- Machine-readable JSON format (no ambiguity)
- Updated after EVERY significant action
- Cross-verified with actual system state
- Tracks blockers explicitly
- Records what's tested vs what's "done"
- If state conflicts with docs, **state wins**

### Session Start Protocol
```
Step 1: read_file(".stackdock-state.json")
Step 2: Report blockers to user (e.g., "You have 3 critical blockers")
Step 3: Verify critical paths exist (apps/web/.env.local, running processes)
Step 4: Compare state vs reality, report discrepancies
Step 5: Ask user what to tackle next (don't assume)
```

### Never Say "Ready" or "Done" Until
- [ ] User confirms they tested it themselves
- [ ] State file shows `loginTested: true`
- [ ] No critical blockers remain in state file
- [ ] User explicitly marks step as completed

### Updating State File
After ANY action that changes system state:
1. Update `.stackdock-state.json` 
2. Update `lastUpdated` timestamp
3. Move items from `nextSteps` to `completedSteps` if user verified
4. Remove from `blockers[]` only when actually resolved
5. Add new blockers if discovered

### Documentation Hierarchy
1. `.stackdock-state.json` - **GROUND TRUTH** (machine state)
2. `.cursorrules` - **BEHAVIOR RULES** (this file)
3. `README.md` - **PROJECT OVERVIEW** (vision/architecture)
4. `STATE-README.md` - **STATE SYSTEM GUIDE** (how state works)
5. `SETUP_NOW.md` - **SETUP REFERENCE** (consolidated steps)
6. All other `.md` files - **REFERENCE ONLY** (can conflict, state wins)

## ğŸ¯ The Vision

**StackDock is infrastructure's WordPress moment.**

- WordPress democratized content management
- StackDock democratizes infrastructure management
- True FOSS: You own the code (docks, UI, everything)
- Composable: Build your perfect control plane
- Extensible: If it has an API, it can be a dock

**This is generational. Don't fuck it up.**

## ğŸ“ When In Doubt

1. Read `.stackdock-state.json` first
2. Check existing patterns in the codebase
3. Read the architecture docs
4. Ask the user (don't assume)
5. Preserve > Delete
6. Document > Assume
7. Verify > Trust

---

**Remember: The user has $4k invested and a CEO meeting Wednesday. Every decision matters.**
